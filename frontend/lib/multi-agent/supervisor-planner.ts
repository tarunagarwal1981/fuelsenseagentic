/**
 * Supervisor Planner
 * 
 * LLM-powered execution planning for multi-agent orchestration.
 * Generates execution plans with tool assignments based on registry metadata.
 */

import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import type { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { LLMFactory } from './llm-factory';
import { AgentRegistry, type AgentRegistryEntry } from './registry';
import type { MultiAgentState } from './state';

// ============================================================================
// Supervisor Plan Interface
// ============================================================================

/**
 * Extracted entities from user query
 */
export interface ExtractedEntities {
  /** Origin port name as mentioned in query */
  origin?: string;
  /** Destination port name as mentioned in query */
  destination?: string;
  /** Vessel name if mentioned */
  vessel_name?: string;
  /** Fuel types requested */
  fuel_types?: Array<{ type: string; quantity?: number; unit?: string }>;
  /** Departure date/time if mentioned */
  departure_date?: string;
  /** Vessel speed if mentioned */
  vessel_speed?: number;
  /** Bunker ports if specifically mentioned */
  bunker_ports?: string[];
  /** Query type classification */
  query_type?: 'route_calculation' | 'bunker_planning' | 'weather_analysis' | 'compliance_check' | 'informational' | 'multi_objective';
}

/**
 * Resolved entity codes (UN/LOCODE from port names)
 */
export interface ResolvedEntityCodes {
  /** Origin port UN/LOCODE */
  origin?: string;
  /** Destination port UN/LOCODE */
  destination?: string;
  /** Bunker port UN/LOCODEs */
  bunker_ports?: string[];
  /** Origin port coordinates [latitude, longitude] */
  origin_coordinates?: [number, number];
  /** Destination port coordinates [latitude, longitude] */
  destination_coordinates?: [number, number];
}

/**
 * Execution plan generated by supervisor LLM
 */
export interface SupervisorPlan {
  /** Agent names in execution order */
  execution_order: string[];
  /** Tool assignments: agent_name -> tool_names[] */
  agent_tool_assignments: Record<string, string[]>;
  /** Reasoning for the plan */
  reasoning: string;
  /** Estimated total execution time in seconds */
  estimated_total_time: number;
  /** Critical path: agents that must succeed */
  critical_path?: string[];
  /** Extracted entities from user query (names as mentioned) */
  extracted_entities?: ExtractedEntities;
  /** Resolved entity codes (UN/LOCODE from WorldPortIndex API) */
  resolved_codes?: ResolvedEntityCodes;
}

// ============================================================================
// Planning Cache
// ============================================================================

interface CachedPlan {
  plan: SupervisorPlan;
  timestamp: number;
}

const planCache = new Map<string, CachedPlan>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
const MAX_CACHE_SIZE = 100; // Maximum cached plans

/**
 * Generate cache key from query only (not state)
 * State changes shouldn't invalidate the plan - the plan is based on query intent
 */
function getCacheKey(query: string, state: MultiAgentState): string {
  // Use only query for cache key - plan should be consistent regardless of current state
  // The plan is about what agents to run, not what data already exists
  return query.substring(0, 200).toLowerCase().trim();
}

/**
 * Clean expired cache entries
 */
function cleanCache(): void {
  const now = Date.now();
  for (const [key, cached] of planCache.entries()) {
    if (now - cached.timestamp > CACHE_TTL) {
      planCache.delete(key);
    }
  }
  
  // If cache is still too large, remove oldest entries
  if (planCache.size > MAX_CACHE_SIZE) {
    const entries = Array.from(planCache.entries())
      .sort((a, b) => a[1].timestamp - b[1].timestamp);
    const toRemove = entries.slice(0, planCache.size - MAX_CACHE_SIZE);
    for (const [key] of toRemove) {
      planCache.delete(key);
    }
  }
}

// ============================================================================
// Entity Resolution
// ============================================================================

/**
 * Resolve extracted entity names to port codes using WorldPortIndex API
 * 
 * This function takes port names extracted by the LLM (e.g., "Dubai", "Tokyo")
 * and resolves them to UN/LOCODE codes using the WorldPortRepository.
 * 
 * @param entities - Extracted entities with port names
 * @returns Resolved UN/LOCODE codes for each port
 */
async function resolveEntitiesToCodes(
  entities: ExtractedEntities | undefined
): Promise<ResolvedEntityCodes> {
  if (!entities) {
    return {};
  }

  const resolved: ResolvedEntityCodes = {};
  
  // Dynamically import ServiceContainer to avoid circular dependencies
  const { ServiceContainer } = await import('@/lib/repositories/service-container');
  const portRepo = ServiceContainer.getInstance().getPortRepository();
  
  // Resolve origin port name to UN/LOCODE and coordinates
  if (entities.origin) {
    try {
      console.log(`ðŸ” [SUPERVISOR-RESOLVER] Resolving origin: "${entities.origin}"`);
      const port = await portRepo.findByName(entities.origin);
      
      if (port) {
        resolved.origin = port.code;  // UN/LOCODE
        resolved.origin_coordinates = port.coordinates;  // [lat, lon]
        console.log(`âœ… [SUPERVISOR-RESOLVER] Origin resolved: ${entities.origin} â†’ ${port.code} (${port.name})`);
        console.log(`   Coordinates: [${port.coordinates[0]}, ${port.coordinates[1]}]`);
      } else {
        console.warn(`âš ï¸  [SUPERVISOR-RESOLVER] Could not resolve origin: "${entities.origin}"`);
        console.warn(`   Will attempt regex-based extraction as fallback`);
      }
    } catch (error) {
      console.error(`âŒ [SUPERVISOR-RESOLVER] Error resolving origin "${entities.origin}":`, error);
    }
  }
  
  // Resolve destination port name to UN/LOCODE and coordinates
  if (entities.destination) {
    try {
      console.log(`ðŸ” [SUPERVISOR-RESOLVER] Resolving destination: "${entities.destination}"`);
      const port = await portRepo.findByName(entities.destination);
      
      if (port) {
        resolved.destination = port.code;  // UN/LOCODE
        resolved.destination_coordinates = port.coordinates;  // [lat, lon]
        console.log(`âœ… [SUPERVISOR-RESOLVER] Destination resolved: ${entities.destination} â†’ ${port.code} (${port.name})`);
        console.log(`   Coordinates: [${port.coordinates[0]}, ${port.coordinates[1]}]`);
      } else {
        console.warn(`âš ï¸  [SUPERVISOR-RESOLVER] Could not resolve destination: "${entities.destination}"`);
        console.warn(`   Will attempt regex-based extraction as fallback`);
      }
    } catch (error) {
      console.error(`âŒ [SUPERVISOR-RESOLVER] Error resolving destination "${entities.destination}":`, error);
    }
  }
  
  // Resolve bunker ports if specified
  if (entities.bunker_ports && entities.bunker_ports.length > 0) {
    resolved.bunker_ports = [];
    
    for (const bunkerPortName of entities.bunker_ports) {
      try {
        console.log(`ðŸ” [SUPERVISOR-RESOLVER] Resolving bunker port: "${bunkerPortName}"`);
        const port = await portRepo.findByName(bunkerPortName);
        
        if (port) {
          resolved.bunker_ports.push(port.code);
          console.log(`âœ… [SUPERVISOR-RESOLVER] Bunker port resolved: ${bunkerPortName} â†’ ${port.code}`);
        } else {
          console.warn(`âš ï¸  [SUPERVISOR-RESOLVER] Could not resolve bunker port: "${bunkerPortName}"`);
        }
      } catch (error) {
        console.error(`âŒ [SUPERVISOR-RESOLVER] Error resolving bunker port "${bunkerPortName}":`, error);
      }
    }
  }
  
  // Log resolution summary
  const resolvedCount = [
    resolved.origin ? 1 : 0,
    resolved.destination ? 1 : 0,
    resolved.bunker_ports?.length || 0
  ].reduce((a, b) => a + b, 0);
  
  console.log(`ðŸ“Š [SUPERVISOR-RESOLVER] Resolution complete: ${resolvedCount} ports resolved`);
  
  return resolved;
}

// ============================================================================
// Plan Generation
// ============================================================================

/**
 * Generate execution plan using LLM and registry metadata
 * 
 * @param userQuery - User's query
 * @param currentState - Current multi-agent state
 * @param availableAgents - Registered agents from registry
 * @returns Execution plan with agent order and tool assignments
 */
export async function generateExecutionPlan(
  userQuery: string,
  currentState: MultiAgentState,
  availableAgents: AgentRegistryEntry[]
): Promise<SupervisorPlan> {
  // Check cache first
  const cacheKey = getCacheKey(userQuery, currentState);
  const cached = planCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log('ðŸ“‹ [SUPERVISOR-PLANNER] Using cached execution plan');
    return cached.plan;
  }
  
  // Clean cache periodically
  cleanCache();
  
  // Get supervisor LLM with validation
  let supervisorLLM: BaseChatModel;
  try {
    supervisorLLM = LLMFactory.getLLMForTask('supervisor_planning');
    
    // Validate LLM before use
    if (!supervisorLLM) {
      throw new Error('supervisorLLM is null or undefined');
    }
    if (typeof supervisorLLM.invoke !== 'function') {
      throw new Error('supervisorLLM.invoke is not a function');
    }
  } catch (error) {
    console.error('âŒ [SUPERVISOR-PLANNER] Failed to get supervisor LLM:', error);
    throw new Error(`LLM initialization failed: ${error instanceof Error ? error.message : String(error)}`);
  }
  
  // Build registry context as JSON
  const registryJSON = AgentRegistry.toJSON();
  
  // Analyze current state
  const stateAnalysis = {
    has_route_data: !!currentState.route_data,
    has_vessel_timeline: !!currentState.vessel_timeline,
    has_weather_forecast: !!currentState.weather_forecast,
    has_weather_consumption: !!currentState.weather_consumption,
    has_bunker_ports: !!currentState.bunker_ports,
    has_port_prices: !!currentState.port_prices,
    has_bunker_analysis: !!currentState.bunker_analysis,
    agent_errors: Object.keys(currentState.agent_errors || {}),
    agent_status: currentState.agent_status || {},
  };
  
  // Build system prompt
  const systemPrompt = `You are a supervisor orchestrating a multi-agent maritime planning system.

Your task is to:
1. EXTRACT KEY ENTITIES from the user's natural language query
2. CLASSIFY the query type (route, bunker, weather, compliance, etc.)
3. GENERATE an execution plan with agent order and tool assignments
4. ENSURE prerequisites are met before agents execute

ENTITY EXTRACTION (CRITICAL):
Extract the following entities from the user's query:

1. PORT NAMES:
   - Origin: Where the voyage starts (e.g., "Dubai", "Singapore", "Rotterdam")
   - Destination: Where the voyage ends (e.g., "Tokyo", "New York", "London")
   - Bunker ports: Ports specifically mentioned for bunkering
   - Extract port names AS THEY APPEAR in the query (preserve casing)
   - Handle variations: "from X to Y", "between X and Y", "X-Y", "route to Y"
   - DO NOT split city names (e.g., "Tokyo" should not become "to" + "kyo")

2. VESSEL INFORMATION:
   - Vessel name if mentioned (e.g., "MV Pacific", "vessel ABC")
   - Vessel speed in knots if mentioned (e.g., "14 knots", "15kt")

3. FUEL REQUIREMENTS:
   - Fuel type: VLSFO, LSFO, HSFO, MGO, LSMGO, LSGO
   - Quantity and unit (e.g., "650 MT", "500 tons")
   - Multiple fuel types: "650 MT VLSFO and 80 MT LSGO"
   - If NOT specified, default to VLSFO

4. DATES/TIMES:
   - Departure date/time if mentioned
   - If NOT specified, assume departure is tomorrow: ${new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0]}

5. QUERY TYPE:
   - route_calculation: User wants route info (distance, duration, waypoints)
   - bunker_planning: User wants bunker recommendations (ports, prices, quantities)
   - weather_analysis: User wants weather forecasts or conditions
   - compliance_check: User asks about ECA zones, regulations
   - informational: General questions about ports, vessels, etc.
   - multi_objective: Combines multiple objectives

ENTITY EXTRACTION EXAMPLES:

Example 1 - Basic route query:
Query: "give me route between Dubai and tokyo"
Extract: {
  "query_type": "route_calculation",
  "origin": "Dubai",
  "destination": "Tokyo",
  "vessel_speed": null,
  "fuel_types": [],
  "departure_date": null
}

Example 2 - Route with UN/LOCODE codes:
Query: "calculate route from SGSIN to NLRTM"
Extract: {
  "query_type": "route_calculation",
  "origin": "SGSIN",
  "destination": "NLRTM",
  "vessel_speed": null,
  "fuel_types": [],
  "departure_date": null
}
Note: If user provides codes (SGSIN, NLRTM), extract them AS-IS. The resolver will handle them.

Example 3 - Bunker planning query:
Query: "find bunker ports from Singapore to Rotterdam with 500MT VLSFO"
Extract: {
  "query_type": "bunker_planning",
  "origin": "Singapore",
  "destination": "Rotterdam",
  "vessel_speed": null,
  "fuel_types": [{"type": "VLSFO", "quantity": 500, "unit": "MT"}],
  "departure_date": null
}

Example 4 - Multiple fuel types:
Query: "bunker planning for 650 MT VLSFO and 80 MT LSGO from Hong Kong to Tokyo"
Extract: {
  "query_type": "bunker_planning",
  "origin": "Hong Kong",
  "destination": "Tokyo",
  "vessel_speed": null,
  "fuel_types": [
    {"type": "VLSFO", "quantity": 650, "unit": "MT"},
    {"type": "LSGO", "quantity": 80, "unit": "MT"}
  ],
  "departure_date": null
}

Example 5 - Route with vessel speed:
Query: "route from Shanghai to Los Angeles at 18 knots"
Extract: {
  "query_type": "route_calculation",
  "origin": "Shanghai",
  "destination": "Los Angeles",
  "vessel_speed": 18,
  "fuel_types": [],
  "departure_date": null
}

Example 6 - Informational query (no ports):
Query: "what's the weather forecast for next week?"
Extract: {
  "query_type": "informational",
  "origin": null,
  "destination": null,
  "vessel_speed": null,
  "fuel_types": [],
  "departure_date": null
}
Note: No route needed - this is an informational query.

Example 7 - Hyphenated format:
Query: "Singapore-New York route"
Extract: {
  "query_type": "route_calculation",
  "origin": "Singapore",
  "destination": "New York",
  "vessel_speed": null,
  "fuel_types": [],
  "departure_date": null
}

Example 8 - Missing origin:
Query: "route to Tokyo"
Extract: {
  "query_type": "route_calculation",
  "origin": null,
  "destination": "Tokyo",
  "vessel_speed": null,
  "fuel_types": [],
  "departure_date": null
}
Note: Missing origin - extraction is still valid, downstream will handle error.

CRITICAL EXTRACTION RULES:
- NEVER split city names (Tokyo, Boston, Toronto, Togo - keep intact!)
- Extract port names/codes AS THEY APPEAR in the query
- Preserve capitalization (user might provide exact codes)
- If no ports mentioned, set to null (don't guess or invent)
- Default fuel type is VLSFO only if bunker planning is needed

Available Agents and Tools:
${registryJSON}

Current State:
- Route data: ${stateAnalysis.has_route_data ? 'âœ… Available' : 'âŒ Missing'}
- Vessel timeline: ${stateAnalysis.has_vessel_timeline ? 'âœ… Available' : 'âŒ Missing'}
- Weather forecast: ${stateAnalysis.has_weather_forecast ? 'âœ… Available' : 'âŒ Missing'}
- Weather consumption: ${stateAnalysis.has_weather_consumption ? 'âœ… Available' : 'âŒ Missing'}
- Bunker ports: ${stateAnalysis.has_bunker_ports ? 'âœ… Available' : 'âŒ Missing'}
- Port prices: ${stateAnalysis.has_port_prices ? 'âœ… Available' : 'âŒ Missing'}
- Bunker analysis: ${stateAnalysis.has_bunker_analysis ? 'âœ… Available' : 'âŒ Missing'}

Agent Status:
${Object.entries(stateAnalysis.agent_status)
  .map(([agent, status]) => `- ${agent}: ${status}`)
  .join('\n')}

${stateAnalysis.agent_errors.length > 0 
  ? `Agent Errors:\n${stateAnalysis.agent_errors.map(e => `- ${e}`).join('\n')}`
  : ''}

PLANNING RULES:
1. Only assign tools that are actually needed based on current state
2. Ensure prerequisites are met (either already in state or will be produced by earlier agents)
3. Don't assign tools if their output already exists in state
4. Respect when_to_use and when_not_to_use conditions from tool metadata
5. Order agents so prerequisites are produced before they're needed
6. IMPORTANT: If the query requires bunker analysis (fuel planning), the weather_agent MUST be assigned BOTH:
   - fetch_marine_weather (to get weather forecast)
   - calculate_weather_consumption (to calculate weather-adjusted fuel consumption)
   This is required because bunker analysis needs weather consumption data to provide accurate recommendations.

7. WEATHER SAFETY FOR BUNKERING: If query contains keywords like:
   - "safe bunkering", "bunkering weather", "weather for bunkering", "weather safety"
   - "weather conditions", "bunkering conditions"
   Then bunker_agent MUST be assigned the check_bunker_port_weather tool.
   This tool checks if ports have safe conditions (wave â‰¤1.5m, wind â‰¤25kt) during bunkering window.
   Note: This tool is SHARED between weather_agent and bunker_agent.

8. MULTI-FUEL TYPE HANDLING:
   - If query specifies multiple fuel types (e.g., "650 MT VLSFO and 80 MT LSGO"), extract:
     * Primary fuel type and quantity (e.g., "VLSFO: 650 MT")
     * Secondary fuel type and quantity (e.g., "LSGO: 80 MT")
   - Include fuel requirements in bunker_agent's task_description
   - Bunker agent must find ports with ALL required fuel types
   - Example task_description: "Find ports with VLSFO (650 MT) and LSGO (80 MT), check weather safety"

9. DEFAULT FUEL TYPE:
   - If query does NOT specify fuel type, assume VLSFO as default
   - Add to task_description: "Fuel type not specified, using VLSFO as default"
   - Note: Future enhancement will add human-in-loop to confirm fuel type selection

10. HUMAN-IN-LOOP ARCHITECTURE (FUTURE):
    - System is designed to support human approval for high-stakes decisions
    - Flag in task_description when human confirmation would be beneficial:
      * "fuel_type_unspecified" - User didn't mention fuel type
      * "large_quantity" - Fuel quantity >500 MT (high-cost decision)
      * "weather_marginal" - Weather conditions are borderline
    - These flags will be used by future human-in-loop UI components

11. DEFAULT DEPARTURE DATE:
    - If query does NOT specify departure date/time
    - Assume departure is tomorrow (next day from current date)
    - Calculate based on current date: ${new Date().toISOString()}
    - Add to task_description: "Departure: Tomorrow (not specified by user)"
    - Estimate arrival times for bunker ports based on this assumption
    - Note: User should be informed in final output that departure was assumed

Return a JSON object with this EXACT structure:
{
  "extracted_entities": {
    "query_type": "route_calculation",
    "origin": "Dubai",
    "destination": "Tokyo",
    "vessel_name": null,
    "vessel_speed": null,
    "fuel_types": [{"type": "VLSFO", "quantity": 650, "unit": "MT"}],
    "departure_date": null,
    "bunker_ports": []
  },
  "execution_order": ["route_agent", "weather_agent", "bunker_agent"],
  "agent_tool_assignments": {
    "route_agent": ["calculate_route", "calculate_weather_timeline"],
    "weather_agent": ["fetch_marine_weather"],
    "bunker_agent": ["find_bunker_ports", "get_fuel_prices", "analyze_bunker_options"]
  },
  "reasoning": "Brief explanation of why this plan and what was extracted",
  "estimated_total_time": 12,
  "critical_path": ["route_agent", "weather_agent"]
}

IMPORTANT: The extracted_entities field is MANDATORY. Always extract port names, query type, and other entities from the user's natural language query.`;

  try {
    // Call LLM with structured output
    const response = await supervisorLLM.invoke([
      new SystemMessage(systemPrompt),
      new HumanMessage(`User Query: "${userQuery}"\n\nGenerate an execution plan.`),
    ]);
    
    // Parse response
    let plan: SupervisorPlan;
    const content = typeof response.content === 'string' 
      ? response.content 
      : JSON.stringify(response.content);
    
    // Try to extract JSON from response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      plan = JSON.parse(jsonMatch[0]);
    } else {
      throw new Error('No JSON found in LLM response');
    }
    
    // ========================================================================
    // Entity Resolution: Convert extracted names to UN/LOCODE codes
    // ========================================================================
    if (plan.extracted_entities) {
      console.log('ðŸ”§ [SUPERVISOR-PLANNER] Resolving extracted entities to port codes...');
      
      try {
        const resolvedCodes = await resolveEntitiesToCodes(plan.extracted_entities);
        plan.resolved_codes = resolvedCodes;
        
        // Log resolution results
        if (resolvedCodes.origin || resolvedCodes.destination) {
          console.log('âœ… [SUPERVISOR-PLANNER] Entity resolution successful:', {
            origin: resolvedCodes.origin ? `${plan.extracted_entities.origin} â†’ ${resolvedCodes.origin}` : 'not resolved',
            destination: resolvedCodes.destination ? `${plan.extracted_entities.destination} â†’ ${resolvedCodes.destination}` : 'not resolved',
          });
        } else {
          console.warn('âš ï¸  [SUPERVISOR-PLANNER] No entities were resolved - agents will use fallback extraction');
        }
      } catch (resolutionError) {
        console.error('âŒ [SUPERVISOR-PLANNER] Entity resolution failed:', resolutionError);
        // Continue without resolved codes - agents will use fallback extraction
        plan.resolved_codes = {};
      }
    } else {
      console.warn('âš ï¸  [SUPERVISOR-PLANNER] No entities extracted from query - agents will use fallback extraction');
    }
    
    // Validate plan
    const validatedPlan = validatePlan(plan, availableAgents, currentState);
    
    // Cache the plan
    planCache.set(cacheKey, {
      plan: validatedPlan,
      timestamp: Date.now(),
    });
    
    console.log('âœ… [SUPERVISOR-PLANNER] Generated execution plan:', {
      agents: validatedPlan.execution_order,
      total_tools: Object.values(validatedPlan.agent_tool_assignments)
        .reduce((sum, tools) => sum + tools.length, 0),
    });
    
    return validatedPlan;
  } catch (error) {
    console.error('âŒ [SUPERVISOR-PLANNER] Plan generation failed:', error);
    throw error;
  }
}

// ============================================================================
// Plan Validation
// ============================================================================

/**
 * Validate execution plan
 */
function validatePlan(
  plan: any,
  availableAgents: AgentRegistryEntry[],
  state: MultiAgentState
): SupervisorPlan {
  // Ensure required fields exist
  if (!plan.execution_order || !Array.isArray(plan.execution_order)) {
    throw new Error('Plan missing execution_order');
  }
  if (!plan.agent_tool_assignments || typeof plan.agent_tool_assignments !== 'object') {
    throw new Error('Plan missing agent_tool_assignments');
  }
  
  // Log extracted entities if present
  if (plan.extracted_entities) {
    console.log('ðŸ” [SUPERVISOR-PLANNER] Extracted entities:', {
      query_type: plan.extracted_entities.query_type,
      origin: plan.extracted_entities.origin,
      destination: plan.extracted_entities.destination,
      vessel_speed: plan.extracted_entities.vessel_speed,
      fuel_types: plan.extracted_entities.fuel_types?.map((f: any) => `${f.type}${f.quantity ? ` (${f.quantity}${f.unit || ''})` : ''}`).join(', '),
      departure_date: plan.extracted_entities.departure_date,
    });
  } else {
    console.warn('âš ï¸ [SUPERVISOR-PLANNER] No entities extracted from query');
  }
  
  // Log resolved codes if present
  if (plan.resolved_codes && (plan.resolved_codes.origin || plan.resolved_codes.destination)) {
    console.log('ðŸŽ¯ [SUPERVISOR-PLANNER] Resolved port codes:', {
      origin: plan.resolved_codes.origin,
      destination: plan.resolved_codes.destination,
      bunker_ports: plan.resolved_codes.bunker_ports?.length || 0,
    });
  }
  
  // Validate agents exist in registry
  const agentMap = new Map(availableAgents.map(a => [a.agent_name, a]));
  for (const agentName of plan.execution_order) {
    if (!agentMap.has(agentName)) {
      throw new Error(`Agent ${agentName} not found in registry`);
    }
  }
  
  // Validate tool assignments
  for (const [agentName, toolNames] of Object.entries(plan.agent_tool_assignments)) {
    if (!Array.isArray(toolNames)) {
      throw new Error(`Tool assignments for ${agentName} must be an array`);
    }
    
    const agent = agentMap.get(agentName);
    if (!agent) {
      throw new Error(`Agent ${agentName} not found in registry`);
    }
    
    // Handle deterministic agents gracefully
    // Deterministic agents don't use LLM tool-calling, so clear any suggested tools
    if (AgentRegistry.isDeterministicAgent(agentName)) {
      if ((toolNames as string[]).length > 0) {
        console.warn(
          `âš ï¸ [SUPERVISOR-PLANNER] Agent ${agentName} is deterministic - ` +
          `ignoring ${(toolNames as string[]).length} LLM-suggested tools: ${(toolNames as string[]).join(', ')}`
        );
      }
      // Clear tool assignments for deterministic agents
      plan.agent_tool_assignments[agentName] = [];
      continue; // Skip validation for this agent
    }
    
    // Check all tools exist in agent's available tools (non-deterministic agents only)
    const availableToolNames = agent.available_tools.map(t => t.tool_name);
    for (const toolName of toolNames as string[]) {
      if (!availableToolNames.includes(toolName)) {
        throw new Error(
          `Tool ${toolName} not available for agent ${agentName}. Available: ${availableToolNames.join(', ')}`
        );
      }
    }
  }
  
  // Ensure execution_order matches agent_tool_assignments keys
  const assignedAgents = new Set(Object.keys(plan.agent_tool_assignments));
  for (const agentName of plan.execution_order) {
    if (!assignedAgents.has(agentName) && plan.agent_tool_assignments[agentName]?.length === 0) {
      // Agent in order but no tools assigned - this is OK (agent might be skipped)
      continue;
    }
  }
  
  // Build validated plan
  const validated: SupervisorPlan = {
    execution_order: plan.execution_order,
    agent_tool_assignments: plan.agent_tool_assignments,
    reasoning: plan.reasoning || 'No reasoning provided',
    estimated_total_time: plan.estimated_total_time || 10,
    critical_path: plan.critical_path || plan.execution_order,
    extracted_entities: plan.extracted_entities, // Include extracted entities
    resolved_codes: plan.resolved_codes, // Include resolved UN/LOCODE codes
  };
  
  return validated;
}

