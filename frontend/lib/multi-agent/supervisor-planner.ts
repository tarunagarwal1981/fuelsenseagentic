/**
 * Supervisor Planner
 * 
 * LLM-powered execution planning for multi-agent orchestration.
 * Generates execution plans with tool assignments based on registry metadata.
 */

import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import type { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { LLMFactory } from './llm-factory';
import { AgentRegistry, type AgentRegistryEntry } from './registry';
import type { MultiAgentState } from './state';

// ============================================================================
// Supervisor Plan Interface
// ============================================================================

/**
 * Execution plan generated by supervisor LLM
 */
export interface SupervisorPlan {
  /** Agent names in execution order */
  execution_order: string[];
  /** Tool assignments: agent_name -> tool_names[] */
  agent_tool_assignments: Record<string, string[]>;
  /** Reasoning for the plan */
  reasoning: string;
  /** Estimated total execution time in seconds */
  estimated_total_time: number;
  /** Critical path: agents that must succeed */
  critical_path?: string[];
}

// ============================================================================
// Planning Cache
// ============================================================================

interface CachedPlan {
  plan: SupervisorPlan;
  timestamp: number;
}

const planCache = new Map<string, CachedPlan>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
const MAX_CACHE_SIZE = 100; // Maximum cached plans

/**
 * Generate cache key from query only (not state)
 * State changes shouldn't invalidate the plan - the plan is based on query intent
 */
function getCacheKey(query: string, state: MultiAgentState): string {
  // Use only query for cache key - plan should be consistent regardless of current state
  // The plan is about what agents to run, not what data already exists
  return query.substring(0, 200).toLowerCase().trim();
}

/**
 * Clean expired cache entries
 */
function cleanCache(): void {
  const now = Date.now();
  for (const [key, cached] of planCache.entries()) {
    if (now - cached.timestamp > CACHE_TTL) {
      planCache.delete(key);
    }
  }
  
  // If cache is still too large, remove oldest entries
  if (planCache.size > MAX_CACHE_SIZE) {
    const entries = Array.from(planCache.entries())
      .sort((a, b) => a[1].timestamp - b[1].timestamp);
    const toRemove = entries.slice(0, planCache.size - MAX_CACHE_SIZE);
    for (const [key] of toRemove) {
      planCache.delete(key);
    }
  }
}

// ============================================================================
// Plan Generation
// ============================================================================

/**
 * Generate execution plan using LLM and registry metadata
 * 
 * @param userQuery - User's query
 * @param currentState - Current multi-agent state
 * @param availableAgents - Registered agents from registry
 * @returns Execution plan with agent order and tool assignments
 */
export async function generateExecutionPlan(
  userQuery: string,
  currentState: MultiAgentState,
  availableAgents: AgentRegistryEntry[]
): Promise<SupervisorPlan> {
  // Check cache first
  const cacheKey = getCacheKey(userQuery, currentState);
  const cached = planCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log('ðŸ“‹ [SUPERVISOR-PLANNER] Using cached execution plan');
    return cached.plan;
  }
  
  // Clean cache periodically
  cleanCache();
  
  // Get supervisor LLM with validation
  let supervisorLLM: BaseChatModel;
  try {
    supervisorLLM = LLMFactory.getLLMForTask('supervisor_planning');
    
    // Validate LLM before use
    if (!supervisorLLM) {
      throw new Error('supervisorLLM is null or undefined');
    }
    if (typeof supervisorLLM.invoke !== 'function') {
      throw new Error('supervisorLLM.invoke is not a function');
    }
  } catch (error) {
    console.error('âŒ [SUPERVISOR-PLANNER] Failed to get supervisor LLM:', error);
    throw new Error(`LLM initialization failed: ${error instanceof Error ? error.message : String(error)}`);
  }
  
  // Build registry context as JSON
  const registryJSON = AgentRegistry.toJSON();
  
  // Analyze current state
  const stateAnalysis = {
    has_route_data: !!currentState.route_data,
    has_vessel_timeline: !!currentState.vessel_timeline,
    has_weather_forecast: !!currentState.weather_forecast,
    has_weather_consumption: !!currentState.weather_consumption,
    has_bunker_ports: !!currentState.bunker_ports,
    has_port_prices: !!currentState.port_prices,
    has_bunker_analysis: !!currentState.bunker_analysis,
    agent_errors: Object.keys(currentState.agent_errors || {}),
    agent_status: currentState.agent_status || {},
  };
  
  // Build system prompt
  const systemPrompt = `You are a supervisor orchestrating a multi-agent maritime planning system.

Your task is to generate an execution plan that:
1. Determines which agents need to run (in order)
2. Assigns specific tools to each agent based on what work needs to be done
3. Ensures prerequisites are met before agents execute

Available Agents and Tools:
${registryJSON}

Current State:
- Route data: ${stateAnalysis.has_route_data ? 'âœ… Available' : 'âŒ Missing'}
- Vessel timeline: ${stateAnalysis.has_vessel_timeline ? 'âœ… Available' : 'âŒ Missing'}
- Weather forecast: ${stateAnalysis.has_weather_forecast ? 'âœ… Available' : 'âŒ Missing'}
- Weather consumption: ${stateAnalysis.has_weather_consumption ? 'âœ… Available' : 'âŒ Missing'}
- Bunker ports: ${stateAnalysis.has_bunker_ports ? 'âœ… Available' : 'âŒ Missing'}
- Port prices: ${stateAnalysis.has_port_prices ? 'âœ… Available' : 'âŒ Missing'}
- Bunker analysis: ${stateAnalysis.has_bunker_analysis ? 'âœ… Available' : 'âŒ Missing'}

Agent Status:
${Object.entries(stateAnalysis.agent_status)
  .map(([agent, status]) => `- ${agent}: ${status}`)
  .join('\n')}

${stateAnalysis.agent_errors.length > 0 
  ? `Agent Errors:\n${stateAnalysis.agent_errors.map(e => `- ${e}`).join('\n')}`
  : ''}

Rules:
1. Only assign tools that are actually needed based on current state
2. Ensure prerequisites are met (either already in state or will be produced by earlier agents)
3. Don't assign tools if their output already exists in state
4. Respect when_to_use and when_not_to_use conditions from tool metadata
5. Order agents so prerequisites are produced before they're needed
6. IMPORTANT: If the query requires bunker analysis (fuel planning), the weather_agent MUST be assigned BOTH:
   - fetch_marine_weather (to get weather forecast)
   - calculate_weather_consumption (to calculate weather-adjusted fuel consumption)
   This is required because bunker analysis needs weather consumption data to provide accurate recommendations.

7. WEATHER SAFETY FOR BUNKERING: If query contains keywords like:
   - "safe bunkering", "bunkering weather", "weather for bunkering", "weather safety"
   - "weather conditions", "bunkering conditions"
   Then bunker_agent MUST be assigned the check_bunker_port_weather tool.
   This tool checks if ports have safe conditions (wave â‰¤1.5m, wind â‰¤25kt) during bunkering window.
   Note: This tool is SHARED between weather_agent and bunker_agent.

8. MULTI-FUEL TYPE HANDLING:
   - If query specifies multiple fuel types (e.g., "650 MT VLSFO and 80 MT LSGO"), extract:
     * Primary fuel type and quantity (e.g., "VLSFO: 650 MT")
     * Secondary fuel type and quantity (e.g., "LSGO: 80 MT")
   - Include fuel requirements in bunker_agent's task_description
   - Bunker agent must find ports with ALL required fuel types
   - Example task_description: "Find ports with VLSFO (650 MT) and LSGO (80 MT), check weather safety"

9. DEFAULT FUEL TYPE:
   - If query does NOT specify fuel type, assume VLSFO as default
   - Add to task_description: "Fuel type not specified, using VLSFO as default"
   - Note: Future enhancement will add human-in-loop to confirm fuel type selection

10. HUMAN-IN-LOOP ARCHITECTURE (FUTURE):
    - System is designed to support human approval for high-stakes decisions
    - Flag in task_description when human confirmation would be beneficial:
      * "fuel_type_unspecified" - User didn't mention fuel type
      * "large_quantity" - Fuel quantity >500 MT (high-cost decision)
      * "weather_marginal" - Weather conditions are borderline
    - These flags will be used by future human-in-loop UI components

11. DEFAULT DEPARTURE DATE:
    - If query does NOT specify departure date/time
    - Assume departure is tomorrow (next day from current date)
    - Calculate based on current date: ${new Date().toISOString()}
    - Add to task_description: "Departure: Tomorrow (not specified by user)"
    - Estimate arrival times for bunker ports based on this assumption
    - Note: User should be informed in final output that departure was assumed

Return a JSON object with this structure:
{
  "execution_order": ["route_agent", "weather_agent", "bunker_agent"],
  "agent_tool_assignments": {
    "route_agent": ["calculate_route", "calculate_weather_timeline"],
    "weather_agent": ["fetch_marine_weather"],
    "bunker_agent": ["find_bunker_ports", "get_fuel_prices", "analyze_bunker_options"]
  },
  "reasoning": "Brief explanation of why this plan",
  "estimated_total_time": 12,
  "critical_path": ["route_agent", "weather_agent"]
}`;

  try {
    // Call LLM with structured output
    const response = await supervisorLLM.invoke([
      new SystemMessage(systemPrompt),
      new HumanMessage(`User Query: "${userQuery}"\n\nGenerate an execution plan.`),
    ]);
    
    // Parse response
    let plan: SupervisorPlan;
    const content = typeof response.content === 'string' 
      ? response.content 
      : JSON.stringify(response.content);
    
    // Try to extract JSON from response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      plan = JSON.parse(jsonMatch[0]);
    } else {
      throw new Error('No JSON found in LLM response');
    }
    
    // Validate plan
    const validatedPlan = validatePlan(plan, availableAgents, currentState);
    
    // Cache the plan
    planCache.set(cacheKey, {
      plan: validatedPlan,
      timestamp: Date.now(),
    });
    
    console.log('âœ… [SUPERVISOR-PLANNER] Generated execution plan:', {
      agents: validatedPlan.execution_order,
      total_tools: Object.values(validatedPlan.agent_tool_assignments)
        .reduce((sum, tools) => sum + tools.length, 0),
    });
    
    return validatedPlan;
  } catch (error) {
    console.error('âŒ [SUPERVISOR-PLANNER] Plan generation failed:', error);
    throw error;
  }
}

// ============================================================================
// Plan Validation
// ============================================================================

/**
 * Validate execution plan
 */
function validatePlan(
  plan: any,
  availableAgents: AgentRegistryEntry[],
  state: MultiAgentState
): SupervisorPlan {
  // Ensure required fields exist
  if (!plan.execution_order || !Array.isArray(plan.execution_order)) {
    throw new Error('Plan missing execution_order');
  }
  if (!plan.agent_tool_assignments || typeof plan.agent_tool_assignments !== 'object') {
    throw new Error('Plan missing agent_tool_assignments');
  }
  
  // Validate agents exist in registry
  const agentMap = new Map(availableAgents.map(a => [a.agent_name, a]));
  for (const agentName of plan.execution_order) {
    if (!agentMap.has(agentName)) {
      throw new Error(`Agent ${agentName} not found in registry`);
    }
  }
  
  // Validate tool assignments
  for (const [agentName, toolNames] of Object.entries(plan.agent_tool_assignments)) {
    if (!Array.isArray(toolNames)) {
      throw new Error(`Tool assignments for ${agentName} must be an array`);
    }
    
    const agent = agentMap.get(agentName);
    if (!agent) {
      throw new Error(`Agent ${agentName} not found in registry`);
    }
    
    // Handle deterministic agents gracefully
    // Deterministic agents don't use LLM tool-calling, so clear any suggested tools
    if (AgentRegistry.isDeterministicAgent(agentName)) {
      if ((toolNames as string[]).length > 0) {
        console.warn(
          `âš ï¸ [SUPERVISOR-PLANNER] Agent ${agentName} is deterministic - ` +
          `ignoring ${(toolNames as string[]).length} LLM-suggested tools: ${(toolNames as string[]).join(', ')}`
        );
      }
      // Clear tool assignments for deterministic agents
      plan.agent_tool_assignments[agentName] = [];
      continue; // Skip validation for this agent
    }
    
    // Check all tools exist in agent's available tools (non-deterministic agents only)
    const availableToolNames = agent.available_tools.map(t => t.tool_name);
    for (const toolName of toolNames as string[]) {
      if (!availableToolNames.includes(toolName)) {
        throw new Error(
          `Tool ${toolName} not available for agent ${agentName}. Available: ${availableToolNames.join(', ')}`
        );
      }
    }
  }
  
  // Ensure execution_order matches agent_tool_assignments keys
  const assignedAgents = new Set(Object.keys(plan.agent_tool_assignments));
  for (const agentName of plan.execution_order) {
    if (!assignedAgents.has(agentName) && plan.agent_tool_assignments[agentName]?.length === 0) {
      // Agent in order but no tools assigned - this is OK (agent might be skipped)
      continue;
    }
  }
  
  // Build validated plan
  const validated: SupervisorPlan = {
    execution_order: plan.execution_order,
    agent_tool_assignments: plan.agent_tool_assignments,
    reasoning: plan.reasoning || 'No reasoning provided',
    estimated_total_time: plan.estimated_total_time || 10,
    critical_path: plan.critical_path || plan.execution_order,
  };
  
  return validated;
}

