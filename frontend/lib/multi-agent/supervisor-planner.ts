/**
 * Supervisor Planner
 * 
 * LLM-powered execution planning for multi-agent orchestration.
 * Generates execution plans with tool assignments based on registry metadata.
 */

import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import { LLMFactory } from './llm-factory';
import { AgentRegistry, type AgentRegistryEntry } from './registry';
import type { MultiAgentState } from './state';

// ============================================================================
// Supervisor Plan Interface
// ============================================================================

/**
 * Execution plan generated by supervisor LLM
 */
export interface SupervisorPlan {
  /** Agent names in execution order */
  execution_order: string[];
  /** Tool assignments: agent_name -> tool_names[] */
  agent_tool_assignments: Record<string, string[]>;
  /** Reasoning for the plan */
  reasoning: string;
  /** Estimated total execution time in seconds */
  estimated_total_time: number;
  /** Critical path: agents that must succeed */
  critical_path?: string[];
}

// ============================================================================
// Planning Cache
// ============================================================================

interface CachedPlan {
  plan: SupervisorPlan;
  timestamp: number;
}

const planCache = new Map<string, CachedPlan>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
const MAX_CACHE_SIZE = 100; // Maximum cached plans

/**
 * Generate cache key from query and state signature
 */
function getCacheKey(query: string, state: MultiAgentState): string {
  const stateSig = [
    state.route_data ? 'R' : '',
    state.weather_forecast ? 'W' : '',
    state.weather_consumption ? 'WC' : '',
    state.bunker_ports ? 'B' : '',
    state.port_prices ? 'P' : '',
    state.bunker_analysis ? 'BA' : '',
  ].join('');
  return `${query.substring(0, 100)}_${stateSig}`;
}

/**
 * Clean expired cache entries
 */
function cleanCache(): void {
  const now = Date.now();
  for (const [key, cached] of planCache.entries()) {
    if (now - cached.timestamp > CACHE_TTL) {
      planCache.delete(key);
    }
  }
  
  // If cache is still too large, remove oldest entries
  if (planCache.size > MAX_CACHE_SIZE) {
    const entries = Array.from(planCache.entries())
      .sort((a, b) => a[1].timestamp - b[1].timestamp);
    const toRemove = entries.slice(0, planCache.size - MAX_CACHE_SIZE);
    for (const [key] of toRemove) {
      planCache.delete(key);
    }
  }
}

// ============================================================================
// Plan Generation
// ============================================================================

/**
 * Generate execution plan using LLM and registry metadata
 * 
 * @param userQuery - User's query
 * @param currentState - Current multi-agent state
 * @param availableAgents - Registered agents from registry
 * @returns Execution plan with agent order and tool assignments
 */
export async function generateExecutionPlan(
  userQuery: string,
  currentState: MultiAgentState,
  availableAgents: AgentRegistryEntry[]
): Promise<SupervisorPlan> {
  // Check cache first
  const cacheKey = getCacheKey(userQuery, currentState);
  const cached = planCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log('ðŸ“‹ [SUPERVISOR-PLANNER] Using cached execution plan');
    return cached.plan;
  }
  
  // Clean cache periodically
  cleanCache();
  
  // Get supervisor LLM
  const supervisorLLM = LLMFactory.getLLMForTask('supervisor_planning');
  
  // Build registry context as JSON
  const registryJSON = AgentRegistry.toJSON();
  
  // Analyze current state
  const stateAnalysis = {
    has_route_data: !!currentState.route_data,
    has_vessel_timeline: !!currentState.vessel_timeline,
    has_weather_forecast: !!currentState.weather_forecast,
    has_weather_consumption: !!currentState.weather_consumption,
    has_bunker_ports: !!currentState.bunker_ports,
    has_port_prices: !!currentState.port_prices,
    has_bunker_analysis: !!currentState.bunker_analysis,
    agent_errors: Object.keys(currentState.agent_errors || {}),
    agent_status: currentState.agent_status || {},
  };
  
  // Build system prompt
  const systemPrompt = `You are a supervisor orchestrating a multi-agent maritime planning system.

Your task is to generate an execution plan that:
1. Determines which agents need to run (in order)
2. Assigns specific tools to each agent based on what work needs to be done
3. Ensures prerequisites are met before agents execute

Available Agents and Tools:
${registryJSON}

Current State:
- Route data: ${stateAnalysis.has_route_data ? 'âœ… Available' : 'âŒ Missing'}
- Vessel timeline: ${stateAnalysis.has_vessel_timeline ? 'âœ… Available' : 'âŒ Missing'}
- Weather forecast: ${stateAnalysis.has_weather_forecast ? 'âœ… Available' : 'âŒ Missing'}
- Weather consumption: ${stateAnalysis.has_weather_consumption ? 'âœ… Available' : 'âŒ Missing'}
- Bunker ports: ${stateAnalysis.has_bunker_ports ? 'âœ… Available' : 'âŒ Missing'}
- Port prices: ${stateAnalysis.has_port_prices ? 'âœ… Available' : 'âŒ Missing'}
- Bunker analysis: ${stateAnalysis.has_bunker_analysis ? 'âœ… Available' : 'âŒ Missing'}

Agent Status:
${Object.entries(stateAnalysis.agent_status)
  .map(([agent, status]) => `- ${agent}: ${status}`)
  .join('\n')}

${stateAnalysis.agent_errors.length > 0 
  ? `Agent Errors:\n${stateAnalysis.agent_errors.map(e => `- ${e}`).join('\n')}`
  : ''}

Rules:
1. Only assign tools that are actually needed based on current state
2. Ensure prerequisites are met (either already in state or will be produced by earlier agents)
3. Don't assign tools if their output already exists in state
4. Respect when_to_use and when_not_to_use conditions from tool metadata
5. Order agents so prerequisites are produced before they're needed

Return a JSON object with this structure:
{
  "execution_order": ["route_agent", "weather_agent", "bunker_agent"],
  "agent_tool_assignments": {
    "route_agent": ["calculate_route", "calculate_weather_timeline"],
    "weather_agent": ["fetch_marine_weather"],
    "bunker_agent": ["find_bunker_ports", "get_fuel_prices", "analyze_bunker_options"]
  },
  "reasoning": "Brief explanation of why this plan",
  "estimated_total_time": 12,
  "critical_path": ["route_agent", "weather_agent"]
}`;

  try {
    // Call LLM with structured output
    const response = await supervisorLLM.invoke([
      new SystemMessage(systemPrompt),
      new HumanMessage(`User Query: "${userQuery}"\n\nGenerate an execution plan.`),
    ]);
    
    // Parse response
    let plan: SupervisorPlan;
    const content = typeof response.content === 'string' 
      ? response.content 
      : JSON.stringify(response.content);
    
    // Try to extract JSON from response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      plan = JSON.parse(jsonMatch[0]);
    } else {
      throw new Error('No JSON found in LLM response');
    }
    
    // Validate plan
    const validatedPlan = validatePlan(plan, availableAgents, currentState);
    
    // Cache the plan
    planCache.set(cacheKey, {
      plan: validatedPlan,
      timestamp: Date.now(),
    });
    
    console.log('âœ… [SUPERVISOR-PLANNER] Generated execution plan:', {
      agents: validatedPlan.execution_order,
      total_tools: Object.values(validatedPlan.agent_tool_assignments)
        .reduce((sum, tools) => sum + tools.length, 0),
    });
    
    return validatedPlan;
  } catch (error) {
    console.error('âŒ [SUPERVISOR-PLANNER] Plan generation failed:', error);
    throw error;
  }
}

// ============================================================================
// Plan Validation
// ============================================================================

/**
 * Validate execution plan
 */
function validatePlan(
  plan: any,
  availableAgents: AgentRegistryEntry[],
  state: MultiAgentState
): SupervisorPlan {
  // Ensure required fields exist
  if (!plan.execution_order || !Array.isArray(plan.execution_order)) {
    throw new Error('Plan missing execution_order');
  }
  if (!plan.agent_tool_assignments || typeof plan.agent_tool_assignments !== 'object') {
    throw new Error('Plan missing agent_tool_assignments');
  }
  
  // Validate agents exist in registry
  const agentMap = new Map(availableAgents.map(a => [a.agent_name, a]));
  for (const agentName of plan.execution_order) {
    if (!agentMap.has(agentName)) {
      throw new Error(`Agent ${agentName} not found in registry`);
    }
  }
  
  // Validate tool assignments
  for (const [agentName, toolNames] of Object.entries(plan.agent_tool_assignments)) {
    if (!Array.isArray(toolNames)) {
      throw new Error(`Tool assignments for ${agentName} must be an array`);
    }
    
    const agent = agentMap.get(agentName);
    if (!agent) {
      throw new Error(`Agent ${agentName} not found in registry`);
    }
    
    // Check all tools exist in agent's available tools
    const availableToolNames = agent.available_tools.map(t => t.tool_name);
    for (const toolName of toolNames) {
      if (!availableToolNames.includes(toolName)) {
        throw new Error(
          `Tool ${toolName} not available for agent ${agentName}. Available: ${availableToolNames.join(', ')}`
        );
      }
    }
  }
  
  // Ensure execution_order matches agent_tool_assignments keys
  const assignedAgents = new Set(Object.keys(plan.agent_tool_assignments));
  for (const agentName of plan.execution_order) {
    if (!assignedAgents.has(agentName) && plan.agent_tool_assignments[agentName]?.length === 0) {
      // Agent in order but no tools assigned - this is OK (agent might be skipped)
      continue;
    }
  }
  
  // Build validated plan
  const validated: SupervisorPlan = {
    execution_order: plan.execution_order,
    agent_tool_assignments: plan.agent_tool_assignments,
    reasoning: plan.reasoning || 'No reasoning provided',
    estimated_total_time: plan.estimated_total_time || 10,
    critical_path: plan.critical_path || plan.execution_order,
  };
  
  return validated;
}

